归并排序

归并排序与快速排序类似，也采用了“分治法”的思想。

    快速排序：选取基准后，将集合分割为左右子集合再进行递归分组，最后合并排序好的各子集合
    归并排序：将集合均分为左右子集合，各自在内部进行递归排序，最后合并排序好的各子集合

排序过程

merge_sort $ go run main.go
[UNSORTED]:      [6 5 3 1 8 7 2 4]

[DEBUG merged]:  [5 6]		# 第一组组内排序

[DEBUG merged]:  [1 3]		# 第二组

[DEBUG merged]:  [1 3 5 6]	# 第一大组合并

[DEBUG merged]:  [7 8]		# 第三组

[DEBUG merged]:  [2 4]		# 第四组

[DEBUG merged]:  [2 4 7 8]	# 第二大组合并

[DEBUG merged]:  [1 2 3 4 5 6 7 8]	# 合并左右两个组

[SORTED]:        [1 2 3 4 5 6 7 8]


复杂度
时间复杂度

遍历和比较步骤固定，最好、最坏情况、平均复杂度均均为 O(NlogN)
空间复杂度

代码实现中借助 res 中间数组，空间复杂度为 O(N)
稳定性

由于是组内元素进行大小比较，相同元素间的位置不变，排序是稳定的。如：[2, 1, 8, 1]

[2, 1, 8, 1]

[1, 2, 8, 1]

[1, 2, 1, 8]

[1, 1, 2, 8]

整个过程两个 1 的顺序不变。

**使用场景**

归并排序和快速排序一样采用了“分治”的思想：
	归并排序 	快速排序
平均时间复杂度 	O(NlogN) 	O(NlogN)
空间复杂度 	O(N) 	O(logN)
稳定性 	稳定 	不稳定

归并排序本身就高效，此外在适用快排的地方如果要求排序稳定，也可使用归并排序。